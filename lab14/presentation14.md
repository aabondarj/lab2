---
## Front matter
lang: ru-RU
title: Laboratory №14
author: |
	Krupennikova V.
institute: |
	RUDN University, Moscow, Russian Federation
	
date: MAY--2021

## Formatting
toc: false
slide_level: 2
theme: metropolis
header-includes: 
 - \metroset{progressbar=frametitle,sectionpage=progressbar,numbering=fraction}
 - '\makeatletter'
 - '\beamer@ignorenonframefalse'
 - '\makeatother'
aspectratio: 43
section-titles: true
---

## Цель работы

Приобрести  простейшие  навыки  разработки,  анализа, тестирования и отладки приложений в ОС типа UNIX/Linux на примере создания  на  языке  программирования  С  калькулятора  с  простейшими функциями.

## Задание

1.Ознакомиться с теоретическим материалом.

2.Изучить основы программирования в оболочке ОС UNIX/Linux.

3.Выполнить упражнения.

4.Ответить на контрольные вопросы.

## Выполнение:

1) В домашнем  каталоге  создаю  подкаталог ~/work/os/lab_progс помощью команды «mkdir-p~/work/os/lab_prog»

![Создание подкаталога](image/1.png){ #fig:001 width=70% }

##

2)Создала в каталоге файлы: calculate.h, calculate.c, main.c, используя команды «cd~/work/os/lab_prog» и «touch calculate.h calculate.c main.c»

![Создание файлов для работы](image/2.png){ #fig:002 width=70% }

##

Это  будет  примитивнейший  калькулятор,  способный  складывать, вычитать,  умножать  и  делить,  возводить  число  в  степень,  брать квадратный корень, вычислять sin, cos, tan. При запуске он будет запрашивать  первое  число,  операцию,  второе  число.  После  этого программа выведет результат и остановится.Открыв редактор Emacs, приступила к редактированию созданных файлов. Реализация функций калькулятора в файле calculate.с 

![Код для калькулятора](image/3.png){ #fig:003 width=60% }

##

![Продолжение кода](image/4.png){ #fig:004 width=60% }

##

Интерфейсный файл calculate.h, описывающий формат вызова функции калькулятора.

![calculate.h](image/5.png){ #fig:005 width=70% }

##

Основной файл main.c, реализующий интерфейс пользователя к калькулятору

![main.c](image/6.png){ #fig:006 width=70% }

##

3) Выполнила компиляцию программы посредством gcc (версия компилятора:8.3.0-19),используя команды «gcc-ccalculate.c», «gcc-cmain.c» и «gcccalculate.omain.o-ocalcul-lm»

![Команды gcc](image/7.png){ #fig:007 width=70% }

##

4) В ходе компиляции программы никаких ошибок выявлено не было.

5) Создала Makefile с необходимым содержанием

![Makefile](image/8.png){ #fig:008 width=70% }

##

Данный файл необходим для автоматической компиляции файлов calculate.c (цель calculate.o), main.c (цельmain.o), а также их объединения в один исполняемый файл calcul(цель calcul). Цель clean нужна для автоматического удаления файлов. Переменная CC отвечает за утилиту для компиляции. Переменная CFLAGS отвечает за опции в данной утилите. Переменная LIBS отвечает за опции для объединения объектных файлов в один исполняемый файл.

6)Далее исправила Makefile

![Измененный Makefile](image/9.png){ #fig:009 width=70% }

##

В переменную CFLAGS добавила опцию -g, необходимую для компиляции объектных файлов и их использования в программе отладчика GDB. Сделала так, что утилита компиляции выбирается с помощью переменной CC.

После этого я удалила исполняемые и объектные файлы из каталога с помощью команды «make clean». 

Выполнила компиляцию файлов, используя команды «make calculate.o», «make main.o», «make calcul».

##

Далее с помощью gdb выполнила отладку программы calcul. Запустила отладчик GDB, загрузив в него программу для отладки, используя команду: «gdb ./calcul»

![Запуск GDB](image/12.png){ #fig:012 width=70% }

##

Для запуска программы внутри отладчика ввела команду «run»

![Команда «run»](image/13.png){ #fig:013 width=70% }

##

Для постраничного (по 10 строк)	просмотра исходного кода использовала команду «list» 

![Команда «list»](image/14.png){ #fig:014 width=70% }

##

Для просмотра строк с 12 по 15 основного файла использовала команду «list 12,15» 

Для просмотра определённых строк не основного файла использовала команду «list calculate.c:20,29» 

![Команда «list calculate.c:20,29» ](image/16.png){ #fig:016 width=70% }

##

Установила точку останова в файле calculate.c на строке номер 21, используя команды «list calculate.c:20,27» и «break 21»

![Точка останова](image/17.png){ #fig:017 width=70% }

##

Вывела информацию об имеющихся в проекте точках останова с помощью команды «info breakpoints» 

![Вывод информации](image/18.png){ #fig:018 width=70% }

##

Запустила программу внутри отладчика и убедилась, что программа остановилась в момент прохождения точки останова. Использовала команды «run», «5», «−» и «backtrace» 

![Запуск программы](image/19.png){ #fig:019 width=70% }

##

Посмотрела, чему равно на этом этапе значение переменной Numeral, введя команду «print Numeral» 

![Переменная Numeral](image/20.png){ #fig:020 width=70% }

##

Сравнила с результатом вывода на экран после использования команды «display Numeral». Значения совпадают.

![Сравнение](image/21.png){ #fig:021 width=70% }

##

Убрала точки останова с помощью команд «info breakpoints» и «delete 1» 

![Удаление точки останова](image/22.png){ #fig:022 width=70% }

##

7) С помощью утилиты splint проанализировала коды файлов calculate.c и main.c. 

Далее воспользовалась командами «splint calculate.c» и «splint main.c» 

C помощью утилиты splint выяснилось, что в файлах calculate.c и main.c присутствует функция чтения scanf, возвращающая целое число (тип int), но эти числа не используются и нигде не сохранятся. Утилита вывела предупреждение о том, что в файле calculate.c происходит сравнение вещественного числа с нулем. Также возвращаемые значения (тип double) в функциях pow, sqrt, sin, cos и tan записываются в переменную типа float, что свидетельствует о потери данных.

## Вывод

В  ходе  выполнения  данной  лабораторной  работы  я  приобрела простейшие  навыки  разработки,  анализа,  тестирования  и  отладки приложений  в  ОС  типа UNIX/Linux на  примере  создания  на  языке программирования С калькулятора с простейшими функциями.

##

The end.

